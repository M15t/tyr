package auth

import (
	"database/sql"
	"time"

	"tyr/internal/rbac"
	"tyr/internal/types"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
	"github.com/samber/lo"
)

// Login tries to authenticate the user provided by given credentials.
// It retrieves the user from the repository based on the email.
// If there is an error retrieving the user or the user does not exist, it returns an error.
// It then compares the provided password with the user's hashed password.
// If the passwords do not match, it returns an error.
// It checks the grant type and verifies if the user has the required role based on the grant type.
// If the user does not have the required role, it returns an error.
// It checks the status of the user and if the user is blocked, it returns an error.
// Finally, it calls the authenticate function with the user and IsLogin set to true, and returns the result.
func (s *Auth) Login(c echo.Context, data Credentials) (*types.AuthToken, error) {
	existedUser, err := s.repo.User.FindByEmail(c.Request().Context(), data.Email)
	if err != nil || existedUser == nil {
		return nil, ErrInvalidCredentials.SetInternal(err)
	}

	if !s.cr.CompareHashAndPassword(existedUser.Password, data.Password) {
		return nil, ErrInvalidCredentials
	}

	switch data.GrantType {
	case "app":
		if existedUser.Role != rbac.RoleUser {
			return nil, ErrInvalidCredentials
		}
	case "portal":
		if !lo.Contains([]string{rbac.RoleAdmin, rbac.RoleSuperAdmin}, existedUser.Role) {
			return nil, ErrInvalidCredentials
		}
	default:
		return nil, ErrInvalidGrantType
	}

	if existedUser.Status == types.UserStatusBlocked.String() {
		return nil, ErrUserBlocked
	}

	return s.authenticate(c, &AuthenticateInput{
		User:    existedUser,
		IsLogin: true,
	})
}

// RefreshToken refreshes the access token.
// It parses the refresh token using s.jwt.ParseToken function.
// If there is an error parsing the token, it returns ErrInvalidRefreshToken with the internal error.
// It then checks if the token is valid and contains the required claims.
// If the token is invalid or does not contain the required claims, it returns ErrInvalidRefreshToken.
// It retrieves the session ID and user ID from the claims.
// It then finds the session using s.repo.Session.FindByID function.
// If there is an error finding the session or the session does not exist, it returns ErrInvalidRefreshToken with the internal error.
// It checks if the session has expired by comparing the current time with the session's expiration time.
// If the session has expired, it updates the session to blocked and clears the refresh token using s.repo.Session.Update function.
// If there is an error updating the session, it returns ErrInvalidRefreshToken with the internal error.
// It finally calls s.authenticate function with the user from the session and IsLogin set to false, and returns the result.
func (s *Auth) RefreshToken(c echo.Context, data RefreshTokenData) (*types.AuthToken, error) {
	token, err := s.jwt.ParseToken(data.RefreshToken)
	if err != nil {
		return nil, ErrInvalidRefreshToken.SetInternal(err)
	}

	// claims token
	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok || !token.Valid {
		return nil, ErrInvalidRefreshToken
	}

	// get user id and session id from claims
	sessionID, ok := claims["id"].(string)
	userID, ok := claims["uid"].(string)
	existedSession, err := s.repo.Session.FindByID(c.Request().Context(), sessionID, userID)
	if err != nil || existedSession == nil {
		return nil, ErrInvalidRefreshToken.SetInternal(err)
	}

	// check if session is expired
	if time.Now().After(existedSession.ExpiresAt) {
		// update session to blocked
		// clear refresh token
		if err := s.repo.Session.Update(c.Request().Context(), map[string]interface{}{
			"is_blocked":    true,
			"refresh_token": sql.NullString{String: "", Valid: false},
		}, existedSession.ID); err != nil {
			return nil, ErrInvalidRefreshToken.SetInternal(err)
		}

		return nil, ErrTokenExpired
	}

	return s.authenticate(c, &AuthenticateInput{
		User:    existedSession.User,
		IsLogin: false,
	})
}

// Signup creates a new user account with the provided data.
// It checks if the user already exists based on the email and role.
// If the user already exists, it returns an error.
// Otherwise, it creates a new user with the given data and returns an authentication token.
// The authentication token is generated by calling the authenticate function with the created user and IsLogin set to true.
// The created user is assigned the role of rbac.RoleUser.
// The user's email and phone are verified at the current time.
// The user's password is hashed using the s.cr.HashPassword function.
// If there is an error during user creation, it returns the error.
// The function requires an echo.Context and a SignupData struct as input.
// It returns a pointer to types.AuthToken and an error.
func (s *Auth) Signup(c echo.Context, data SignupData) (*types.AuthToken, error) {
	if existed, err := s.repo.User.Existed(c.Request().Context(), map[string]interface{}{
		"email": data.Email,
		"role":  rbac.RoleUser,
	}); err != nil || existed {
		return nil, ErrUserExisted
	}

	now := time.Now()

	user := &types.User{
		FirstName:       data.FirstName,
		LastName:        data.LastName,
		Email:           data.Email,
		EmailVerifiedAt: &now,
		Phone:           data.Phone,
		PhoneVerifiedAt: &now,
		Password:        s.cr.HashPassword(data.Password),

		Role:    rbac.RoleUser,
		Profile: &types.Profile{},
	}

	if err := s.repo.User.Create(c.Request().Context(), user); err != nil {
		return nil, err
	}

	return s.authenticate(c, &AuthenticateInput{
		User:    user,
		IsLogin: true,
	})
}
